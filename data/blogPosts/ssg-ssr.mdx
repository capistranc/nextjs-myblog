---
title: "Building your first website from scratch"
publishedAt: "2020-01-02"
author: Chris Capistran
date: "2020-01-02"
---

Web Development is a curious form of Software Engineering. Paradoxically, it faces a complete overhaul every 10 years while
simultaneously remaining incredibly static.
On the front end we have seen:

- Ruby (on Rails)
- Angular
- VueJS
- React
  In terms of CSS Frameworks:
- Bootstrap
- Materialize
- Tailwind
- ChakraUI

In the backend we're finally seeing PHP slowly die out of relevance as NodeJS continues to prove it can do everything PHP can in Javascript.

CMS tools, aka drag and drop site builders such as WordPress, Wix, Squarespace, etc. have made it possible for people with no programming experience
to simple websites.

Througout all of these advancements in Web Development, Vanilla HTML and CSS has remained the one and only constant. And while these languages themselves
have seen many improvements over time.

- HTML's evolution of event observers constantly add new functionally with better performance over old event observers.
- The evolution of Flex and Grid styling to create device agnostic styling of websites.

The fundamentals have remained the same. Within the realm of SEO: The most Vanilla Method of Deploying Websites is still the most effective.

We recommend using **Static Generation** (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.
You can use Static Generation for many types of pages, including:

- Marketing pages
- Blog posts
- E-commerce product listings
- Help and documentation

You should ask yourself: "Can I pre-render this page **ahead** of a user's request?" If the answer is yes, then you should choose Static Generation.

On the other hand, Static Generation is **not** a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.

In that case, you can use **Server-Side Rendering**. It will be slower, but the pre-rendered page will always be up-to-date. Or you can skip pre-rendering and use client-side JavaScript to populate data.

We recommend using **Static Generation** (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.

You can use Static Generation for many types of pages, including:

- Marketing pages
- Blog posts
- E-commerce product listings
- Help and documentation

You should ask yourself: "Can I pre-render this page **ahead** of a user's request?" If the answer is yes, then you should choose Static Generation.

On the other hand, Static Generation is **not** a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.

In that case, you can use **Server-Side Rendering**. It will be slower, but the pre-rendered page will always be up-to-date. Or you can skip pre-rendering and use client-side JavaScript to populate data.

We recommend using **Static Generation** (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.

You can use Static Generation for many types of pages, including:

- Marketing pages
- Blog posts
- E-commerce product listings
- Help and documentation

You should ask yourself: "Can I pre-render this page **ahead** of a user's request?" If the answer is yes, then you should choose Static Generation.

On the other hand, Static Generation is **not** a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.

In that case, you can use **Server-Side Rendering**. It will be slower, but the pre-rendered page will always be up-to-date. Or you can skip pre-rendering and use client-side JavaScript to populate data.

Whenever I work with Firebase, I always seem to run into small issues that can be very annoying (yet simple) to solve. When I tried to connect my Flutter application to a Firebase backend for one of my personal projects, I ran into some small issues that set me back some time. Because of this, I decided to write a simple and straightforward article showing you how to connect your Flutter application to a firebase backend for both IOS and Android. After this tutorial, you will be all set to add authentication, cloud Firestore, or any other Firebase feature you might want.

## Outline

- [Pre Recs](#pre-reqs)

- [Creating a Firebase Project](#creating-a-firebase-project)

- [Add Firebase to Android](#add-firebase-to-android)

- [Add Firebase to IOS](#add-firebase-to-ios)

- [Finishing Up](#finishing-up)

## Pre Reqs

To keep this tutorial short, I expect that you have the following:

1. You have Flutter installed on your machine
2. You have a Flutter project started already and are ready to connect it with Firebase

If you don’t have those 2 things yet, you can read my last article where I go over how to do just that.

## Creating a Firebase Project

Before we start working in Flutter, we need to create a Firebase project.

1. Navigate to [Firebase console](https://console.firebase.google.com/)

2. Click on **Add Project**

3. Enter a project name

4. Choose if you want Google Analytics to be enabled (I recommend this). You can always enable this later on.

5. Choose what account you want this project to be associated with

6. Click **create project**

After a minute or two, your project will finish creating and you will be brought to the overview page.

## Add Firebase to Android

Next, we will add Firebase to our Android version. We will need to do IOS and Android separately although the process is similar.

![Firebase Console](/images/connect-flutter-to-firebase/console.png)

1. Click on the Android Icon from the overview page

2. Complete the Register App step.

For Android package name use the format: com.[your name or business name].[project name]. For app nickname, use whatever name you’d like.

![Firebase Console](/images/connect-flutter-to-firebase/add.png)

Step 2

3. Download the config file and place it in the app level (in the app folder).

![Firebase Console](/images/connect-flutter-to-firebase/app-level.png)

4. In the project level build.gradle, add the following:

![Firebase Console](/images/connect-flutter-to-firebase/build.gradle.png)

5. In the app level build.gradle add the following:

![Firebase Console](/images/connect-flutter-to-firebase/app-level-build.gradle.png)

6. Lastly, in the app level build.gradle file (same file as above), find the applicationId and change it to the name you chose in step 2. In my case I used com.benjamincarlson.medium_tutorial.

![Firebase Console](/images/connect-flutter-to-firebase/name.png)

At this point we are done. Run the app with an android emulator and make sure everything works. You should see the following image below if everything works as expected.

![Firebase Console](/images/connect-flutter-to-firebase/working-android.png)

## Add Firebase to IOS

Like I said earlier, this is similar to what we did for Android.

Click on the IOS Icon from the overview page

Enter the IOS bundle ID. This can be found by opening your project in Xcode -> click on runner (top right) -> general tab -> Identity

![Firebase Console](/images/connect-flutter-to-firebase/bundle-id.png)

I changed mine from com.example.mediumTutorial to com.benjamincarlson.mediumTutorial.

3. Enter an app nickname and app store ID (both optional)

4. Download the config file. Add the file in the project root by opening Xcode, right clicking on runner, and clicking “add files to runner”. You need to add the file directly through Xcode otherwise you will get an error and the app won’t run.

5. Skip the next 2 steps firebase tells you to do

6. Run the IOS app and make sure everything is working correctly

## Finishing Up

The last thing you want to do is open up pubspec.yaml and add the following under dependencies:

```dart:pubspec.yaml
firebase_auth: ^0.14.0+5
cloud_firestore: ^0.12.9+4
```

Any other firebase tools you want to use will be added here as well.

That’s it guys! I hope you found this article useful and that you are able to successfully connect your Flutter app to firebase!
